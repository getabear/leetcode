import  time
class Solution:
    def longestValidParentheses(self, s: str) -> int:
        #动态规划  dp[i]代表以i结尾的最大有效子串长度
        def fun(s):
            dp=[0 for i in range(len(s))]
            if len(s)<2:
                return 0
            ret=0
            for i in range(1,len(s)):
                if s[i]==')':
                    if s[i-1]=='(':
                        if i>2:
                            dp[i]=dp[i-2]+2
                        else:
                            dp[i]=2
                    elif i-dp[i-1]>0 and s[i-dp[i-1]-1]=='(':
                        dp[i]=dp[i-dp[i-1]-2]+dp[i-1]+2
                if dp[i]>ret:
                    ret=dp[i]
            return ret
        return fun(s)
class Solution2:
    def longestValidParentheses(self, s: str) -> int:

        #方法二:使用滑动窗口,维持最大的有效长度,稍微快了一点点
        def judge(s):
            zhan=[]
            for i in s:
                if i=='(':
                    zhan.append(i)
                if i==')':
                    if len(zhan)>0 and zhan.pop()=='(':
                        continue
                    else:
                        return False
            return len(zhan)==0
        def fun(s):
            end=1
            ret=0
            len_s=len(s)
            for i in range(len_s):
                if i+end<len_s:
                    for j in range(i+end,len_s):
                        if  judge(s[i:j+1]):
                            if j-i+1>ret:
                                ret=j-i+1
                                end=ret
            return ret
        return fun(s)

class Solution1:
    # 方法一,暴力解法,每种可能都去先判断是否为有效字符串,然后计算长度,超时匙肯定的
    def longestValidParentheses(self, s: str) -> int:
        def judge(s):
            zhan = []
            for i in s:
                if i == '(':
                    zhan.append(i)
                if i == ')':
                    if len(zhan) > 0 and zhan.pop() == '(':
                        continue
                    else:
                        return False
            return len(zhan) == 0

        def fun(s: str):
            len_s = len(s)
            max = 0
            for i in range(len_s):
                for j in range(i + 1, len_s):
                    if judge(s[i:j + 1]):
                        if j - i + 1 > max:
                            max = j - i + 1
            return max

        return fun(s)

s="((())())(()))(()()(()(()))(()((((()))))))((()())()))" \
  "()()(()(((((()()()())))()())(()()))((((((())))((()))()()))))" \
  "(()))())))()))()())((()()))))(()(((((())))))()((()(()(())((((())" \
  "(())((()()(()())))())(()(())()()))())(()()()))()(((()())(((()()" \
  "())))(((()()()))(()()))()))()))))))())()()((()(())(()))()((()()()" \
  "((())))()(((()())(()))())())))(((()))))())))()(())))()())))())()" \
  "((()))((()))()))(((())((()()()(()((()((())))((()()))())(()()(()))))" \
  "())((())))(()))()))))))()(()))())(()())))))(()))((())(()((())(((((()" \
  "()()(()()())))(()())()((()(()()))(()(())((()((()))))))))(()(())()())" \
  "()(()(()(()))()()()(()()())))(())(()((((()()))())))(())((()(())())))))" \
  "())()()))(((())))())((()(()))(()()))((())(())))))(()(()((()((()()))))))" \
  "(()()()(()()()(()(())()))()))(((()(())()())(()))())))(((()))())(()((()))" \
  "(()((()()()(())()(()())()(())(()(()((((())()))(((()()(((()())(()()()(())" \
  "()())())(()(()()((()))))()(()))))(((())))()()))(()))((()))))()()))))((((()" \
  "(())()()()((()))((()))())())(()((()()())))))))()))(((()))))))(()())))" \
  "(((()))((()))())))(((()(((())))())(()))))(((()(((((((((((((())(((()))" \
  "((((())())()))())((((())(((())))())(((()))))()())()(())())(()))))()))" \
  "()()()))(((((())()()((()))())(()))()()(()()))(())(()()))()))))(((())))))" \
  "((()()(()()()()((())((((())())))))((((((()((()((())())(()((()))(()())" \
  "())())(()(())(())(()((())((())))(())())))(()()())((((()))))((()(())" \
  "(()(()())))))))))((()())()()))((()(((()((()))(((((()()()()()(()(()" \
  "((()(()))(()(()((()()))))()(()()((((((()((()())()))((())()()(((((()" \
  "(()))))()()((()())((()())()(())((()))()()(()))"
# s=")()())"
a=Solution()
b=Solution2()
print(a.longestValidParentheses(s))
print(time.process_time())